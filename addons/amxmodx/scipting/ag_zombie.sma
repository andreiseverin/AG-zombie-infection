/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fun>
#include <fakemeta>
#include <hamsandwich>
#include <msgstocks>
#include <engine>

#define PLUGIN "AG Zombie Infection"
#define VERSION "1.0"
#define AUTHOR "teylo"

new roundtime,infectiontime
new cv_rtime,cv_infectiontime

new gInfectionStart = 0;


// weapons
new const g_weapon_ents[][] = {
	"weapon_357",
	"weapon_9mmAR",
	"weapon_9mmhandgun",
	"weapon_crossbow",
	"weapon_egon",
	"weapon_gauss",
	"weapon_glock",
	"weapon_handgrenade",
	"weapon_hornetgun",
	"weapon_mp5",
	"weapon_python",
	"weapon_rpg",
	"weapon_satchel",
	"weapon_shotgun",
	"weapon_snark",
	"weapon_tripmine",
	"item_longjump",
	"item_suit",
	"item_battery",
	"item_healthkit",
	"weaponbox"
}
// Item entities
new const g_item_ents[][] = {
	"ammo_357",
	"ammo_9mmAR",
	"ammo_9mmbox",
	"ammo_9mmclip",
	"ammo_ARgrenades",
	"ammo_buckshot",
	"ammo_crossbow",
	"ammo_egonclip",
	"ammo_gaussclip",
	"ammo_glockclip",
	"ammo_mp5clip",
	"ammo_mp5grenades",
	"ammo_rpgclip",
	"item_longjump",
	"item_suit",
	"item_battery",
	"item_healthkit",
	"weaponbox"
}
// "Func" entities
new const g_func_ents[][] = {
	"func_recharge",
	"func_healthcharger",
	"func_tank",
	"func_tankcontrols",
	"func_tanklaser",
	"func_tankmortar",
	"func_tankrocket",
	"monster_barney",
	"monster_scientist"
}

// Infection count
new const SND_VOX_COUNT[][] = {
	"common/null.wav",
	"zx/vox/one.wav",
	"zx/vox/two.wav",
	"zx/vox/three.wav",
	"zx/vox/four.wav",
	"zx/vox/five.wav",
	"zx/vox/six.wav",
	"zx/vox/seven.wav",
	"zx/vox/eight.wav",
	"zx/vox/nine.wav",
	"zx/vox/ten.wav"
};

// Weapon drop count
new const SND_FVOX_COUNT[][] = {
	"common/null.wav",
	"fvox/one.wav",
	"fvox/two.wav",
	"fvox/three.wav",
	"fvox/four.wav",
	"fvox/five.wav",
	"fvox/six.wav",
	"fvox/seven.wav",
	"fvox/eight.wav",
	"fvox/nine.wav",
	"fvox/ten.wav"
};


// TaskIDs
enum (+= 100) {
	TASK_FIRSTROUND = 2019,
	TASK_ROUNDPRESTART,
	TASK_ROUNDSTART,
	TASK_ROUNDEND,
	TASK_FREEZEPERIOD,
	TASK_PLAYERSTATUS,
	TASK_ZOMBIEALERTSND,
	TASK_SENDTOSPEC,
	TASK_CHECKGAMESTATUS,
	TASK_ROUNDTIMER
};


// thunder effect sprites
new gSprLaserDot;
new gSprLgtning;

#define ZOMBIE_ALERT_DELAY 13.5

// SOUNDS
new const SND_ZMB_COMING[][] = { "zx/zmb_coming_1.wav", "zx/zmb_coming_2.wav" };
new const SND_ZMB_ALERT[][] = { "zx/zmb_alert_1.wav", "zx/zmb_alert_2.wav"};
new const SND_HUMAN_DEATH[][] = { "zx/human_death_1.wav", "zx/human_death_2.wav" };
new const SND_ROUND_WIN_HUMAN[][] = { "zx/round_win_human_1.wav" };
new const SND_ROUND_WIN_ZOMBI[][] = { "zx/round_win_zombi_1.wav" };
new const SND_HUM_WEAPON_DROP[][] = { "zx/human_weapon_drop.wav" };

// half-life default sounds for dmg and use
new const CBAR_HIT1[] = "weapons/cbar_hit1.wav";
new const CBAR_HIT2[] = "weapons/cbar_hit2.wav";
new const CBAR_HITBOD1[] = "weapons/cbar_hitbod1.wav";
new const CBAR_HITBOD2[] = "weapons/cbar_hitbod2.wav";
new const CBAR_HITBOD3[] = "weapons/cbar_hitbod3.wav";
new const GUNPICKUP2[] = "items/gunpickup2.wav";
new const WPN_SELECT[] = "common/wpn_select.wav"; // use
new const WPN_DENYSELECT[] = "common/wpn_denyselect.wav"; // can't use

new const SND_ZMB_HITBOD[][] = { "zx/zmb_attack_1.wav", "zx/zmb_attack_2.wav", "zx/zmb_attack_3.wav" };
new const SND_ZMB_HITWALL[][] = { "zx/zmb_wall_1.wav", "zx/zmb_wall_2.wav", "zx/zmb_wall_3.wav" };

// zombie claws model
new const MDL_ZMB_CLAWS[] = "models/zx/v_claws_zombie.mdl";

//light cvar
new gCvarLight;

#define m_iDeaths 377
#define m_szTeamName 383
#define hud_offset 296

#define XTRA_OFS_PLAYER 5

stock static teams[10][16]

new bool:g_infected[33]

new gHudLoc
new g_msg[512]


public plugin_precache()
{
	// thunder sprites
	gSprLaserDot = precache_model("sprites/laserdot.spr");
	gSprLgtning = precache_model("sprites/lgtning.spr");

	// human sounds
	PrecacheSoundList(SND_HUMAN_DEATH, sizeof SND_HUMAN_DEATH);

	// zombie sounds
	PrecacheSoundList(SND_ZMB_ALERT, sizeof SND_ZMB_ALERT);
	PrecacheSoundList(SND_ROUND_WIN_HUMAN, sizeof SND_ROUND_WIN_HUMAN);
	PrecacheSoundList(SND_ROUND_WIN_ZOMBI, sizeof SND_ROUND_WIN_ZOMBI);
	PrecacheSoundList(SND_HUM_WEAPON_DROP, sizeof SND_HUM_WEAPON_DROP);
	PrecacheSoundList(SND_ZMB_HITWALL, sizeof SND_ZMB_HITWALL);
	PrecacheSoundList(SND_ZMB_HITBOD, sizeof SND_ZMB_HITBOD);

	// infection count sound
	PrecacheSoundList(SND_VOX_COUNT, sizeof SND_VOX_COUNT);
	// weapon drop count sound
	PrecacheSoundList(SND_FVOX_COUNT, sizeof SND_FVOX_COUNT);

	// zombie models
	precache_model(MDL_ZMB_CLAWS);

}

public plugin_init()
{

	register_plugin(
	PLUGIN,		//: AG Zombie Infection
	VERSION,	//: 1.0
	AUTHOR		//: teylo
	);


	new ag_gamemode[32];
	get_cvar_string("sv_ag_gamemode", ag_gamemode, charsmax(ag_gamemode));
	if (ag_gamemode[0] && !(equali(ag_gamemode, "zombie") ))
	{
		server_print("[Zombie Infection] The %s plugin can only be run in the ^"zombie^" gamemode on Adrenaline Gamer 6.6 or its Mini version for HL.", PLUGIN);
		pause("ad");
		return;
	}

	gHudLoc = CreateHudSyncObj();
	
	cv_rtime = register_cvar("bh_rtime","2") //mins
	cv_infectiontime = register_cvar("bh_itime","15")  // seconds
	gCvarLight = create_cvar("zx_light", "f", FCVAR_SERVER);
	
	RegisterHam(Ham_Spawn, "player", "playerSpawn",true)
	RegisterHam(Ham_TraceAttack,"player","fw_TraceAttack")
	RegisterHam(Ham_TakeDamage, "player", "TakeDamage")
	register_clcmd("drop", "CmdDrop")

	register_forward(FM_EmitSound, "FwEmitSound")
	
	
	// Thank to Anggara_nothing and his Zombie Mod plugin
	for(new i=0;i<sizeof(g_func_ents);i++)
		RegisterHam(Ham_Use, g_func_ents[i], "fw_UseStaticonary")
	
	for(new i=0;i<sizeof(g_item_ents);i++)
		remove_entity_name(g_item_ents[i])
	
	for(new i=0;i<sizeof(g_weapon_ents);i++)
		remove_entity_name(g_weapon_ents[i])

	// set map lightning level
	new light[32];
	get_pcvar_string(gCvarLight, light, charsmax(light));
	set_lights(light);
	
	check_alive_hud()
	
}

public SetZombieClaws(id) {
	// crowbar is gonna be his claws
	give_item(id, "weapon_crowbar");
	// weapon in first person
	set_pev(id, pev_viewmodel2, MDL_ZMB_CLAWS);
	// remove weapon from third person
	set_pev(id, pev_weaponmodel2, "");
}



public PrecacheSoundList(const sndList[][], size) 
{
	for (new i; i < size; i++)
		precache_sound(sndList[i]);
}

public client_putinserver(id)
{
	set_user_info(id, "model","hgrunt")
}

public client_disconnected(id)
{
	g_infected[id] = false;
}

public playerSpawn(id) 
{
	if (is_user_alive(id)) {
		if(gInfectionStart == 1)
			return PLUGIN_HANDLED
		else 
		{
			gInfectionStart = 1
			infection_start()
		}
	}
	client_print(id, print_chat, "^^8[Zombie Infection] ^^2 Run away from zombies and avoid beeing infected!")
	return PLUGIN_CONTINUE
}

// Infection Round System ------------------------------------------------------------------------------------
public infection_start()
{
	new inum, players[32],player;
	get_players(players, inum)
	// Check if there are enogh player for the infection to can start
	if(inum<2){
		set_hudmessage(0, 255, 0, -1.0, 0.10, 0, 6.0, 12.0)
		show_hudmessage(0, "Zombie Mod need at least 2 players to start!")
		
		set_task(3.0,"infection_start")
		return PLUGIN_CONTINUE
	}

	// get the infection time from cvar
	infectiontime = get_pcvar_num(cv_infectiontime)
	
	// set all players human model
	
	for(new i; i < inum; i++) {
		player = players[i]
		g_infected[player]=false
		set_user_info(player, "model","hgrunt")
		// Do everybody immortal before infection
		set_user_godmode(player, true);
	}
	
	// start infection counter loop
	infection_think()
	
	return PLUGIN_CONTINUE
}

// Infection counter loop
public infection_think()
{
	// show time remaining untill the infection
	static secs; secs = infectiontime
	set_hudmessage(0, 255, 0, -1.0, 0.10, 0, 6.0, 12.0)
	show_hudmessage(0, "^^8Infection in: ^^1%d ^^8seconds",secs)	
	

	// start sound counter untill infection 
	if(infectiontime <= 10 && infectiontime > 0)
		PlaySound(0, SND_VOX_COUNT[infectiontime])


	infectiontime--

	// re-do 1 by 1 untill the round can start
	if(infectiontime)
		set_task(1.0,"infection_think")
	else 
		round_start()
	
	return PLUGIN_CONTINUE
}

// Round System ------------------------------------------------------------------------------------
public round_start()
{
	// this will clean entities like tripmines, satchels, etc...
	ClearField()
	// Do everybody mortal before infection and strip their weapons
	new inum, players[32],player;
	get_players(players, inum)
	
	for(new i; i < inum; i++) {
		player = players[i]
		set_user_godmode(player, false);
		hl_strip_user_weapons(player)
	}

	// random infection of a player
	random_infection()

	// get round time from the cvar
	roundtime = get_pcvar_num(cv_rtime)*60

	round_think()
	
	return PLUGIN_CONTINUE
}

// round counter loop
public round_think()
{
	// show round time in a hud
	static mins; mins = roundtime/60
	static secs; secs = roundtime-mins*60
	set_hudmessage(0, 255, 0, -1.0, 0.10, 0, 6.0, 12.0)
	show_hudmessage(0, "^^8Weapons will arrive in  ^^2%02d:%02d ^^8Try to survive zombies!",mins,secs)	
	
	// start sound counter untill infection 
	if(roundtime <= 10 && roundtime > 0)
		PlaySound(0, SND_FVOX_COUNT[roundtime])

	roundtime--
	
	// sort alive players by model and count them
	static sz_playerModel[32]
	new g_zombie_alive = 0, g_human_alive = 0;
	new inum, players[32],player;
	get_players(players, inum)
	
	for(new i; i < inum; i++) {
		player = players[i]
		if (is_user_alive(player)){
			get_user_info(player,"model",sz_playerModel,sizeof(sz_playerModel))
			if (equali(sz_playerModel, "zombie"))
			{
				g_zombie_alive +=1
			} else {
				g_human_alive +=1
			}
		}
	}

	// check if humans won
	if(!g_zombie_alive){
		round_end(2)
		return PLUGIN_CONTINUE
	// check if zombie won
	}else if(!g_human_alive){
		round_end(1)
		return PLUGIN_CONTINUE
	}
	
	// re-do 1 by 1 untill the round will end
	if(roundtime)
		set_task(1.0,"round_think")
	// all weapons system for humans that survived 
	else
	{
		PlaySound(0, SND_HUM_WEAPON_DROP[random(sizeof SND_HUM_WEAPON_DROP)])
		round_end(0)
	}
		
	return PLUGIN_CONTINUE
}

public round_end(wins)
{
	// Verify end of round time
	new bool:g_endRound
	
	// clear hud message on end
	set_hudmessage(0, 255, 0, -1.0, 0.10, 0, 6.0, 12.0)
	show_hudmessage(0, "")

	// Display winners at the end
	switch(wins){
		case 0: 
		{
			client_print(0, print_chat, "^^8[Zombie Infection] ^^2 Humans managed to survive! Weapons arrived for them!")
			g_endRound = true
		}
		case 1: 
		{
			// initialize human, zombie and infection start to 0
			gInfectionStart = 0
			PlaySound(0, SND_ROUND_WIN_ZOMBI[random(sizeof SND_ROUND_WIN_ZOMBI)]);
			client_print(0, print_chat, "^^8[Zombie Infection] ^^1 ZOMBIES WON !!!")
		}
		case 2: 
		{
			// initialize human, zombie and infection start to 0
			gInfectionStart = 0
			PlaySound(0, SND_ROUND_WIN_HUMAN[random(sizeof SND_ROUND_WIN_HUMAN)])
			client_print(0, print_chat, "^^8[Zombie Infection] ^^2 HUMANS WON !!!")
		}
	}
	

	// send all player spectate at the end of the round if not end of time
	if(!g_endRound)
	{
		set_task(2.0,"sendSpec")
	} else {
		// weapon drop for humans alive
		set_task(2.0,"weapon_drop")
		//check if any team won
		check_win()
	}
}

public weapon_drop()
{
// give weapons to all humans alive
		static sz_idModel[32]
		new inum, players[32],player;
		get_players(players, inum)
		for(new i; i < inum; i++) {
			player = players[i]
			get_user_info(player,"model",sz_idModel,sizeof(sz_idModel))
			if (equali(sz_idModel, "hgrunt") && is_user_alive(player))
			{
				give_weapons(player)
			}
		}
}

// round counter loop
public check_win()
{

	// sort alive players by model and count them
	static sz_playerModel[32]
	new g_zombie_alive = 0, g_human_alive = 0;
	new inum, players[32],player;
	get_players(players, inum)
	
	for(new i; i < inum; i++) {
		player = players[i]
		if (is_user_alive(player)){
			get_user_info(player,"model",sz_playerModel,sizeof(sz_playerModel))
			if (equali(sz_playerModel, "zombie"))
			{
				g_zombie_alive +=1
			} else {
				g_human_alive +=1
			}
		}
	}


	// check if humans won
	if(!g_zombie_alive){
		round_end(2)
		return PLUGIN_CONTINUE
	// check if zombie won
	}else if(!g_human_alive){
		round_end(1)
		return PLUGIN_CONTINUE
	}
	set_task(1.0,"check_win")

	return PLUGIN_CONTINUE
}


// round counter loop
public check_alive_hud()
{

	// sort alive players by model and count them
	static sz_playerModel[32]
	new g_zombie_alive = 0, g_human_alive = 0;
	new inum, players[32],player;
	get_players(players, inum)
	
	for(new i; i < inum; i++) {
		player = players[i]
		if (is_user_alive(player)){
			get_user_info(player,"model",sz_playerModel,sizeof(sz_playerModel))
			if (equali(sz_playerModel, "zombie"))
			{
				g_zombie_alive +=1
			} else {
				g_human_alive +=1
			}
		}
	}

	static pos
	pos = 0
	pos += formatex(g_msg[pos], 511-pos, "^^8teylo's AG Zombie Infection Plugin^n ALIVE STATUS [^^8HUMANS: ^^2%d ^^8| ^^8ZOMBIES: ^^1%d^^8]", g_human_alive,g_zombie_alive)
	print_hud()

	set_task(1.0,"check_alive_hud")

	return PLUGIN_CONTINUE;

}

public print_hud()
{
	new players[32],inum,player
	get_players(players, inum)
	
	for(new i; i < inum; i++) 
	{
		player = players[i]
		set_hudmessage(255, 255, 255, -1.0, 0.0, 0, 1.0, 3.0, 0.1, 0.1)
		ShowSyncHudMsg(player, gHudLoc, "%s", g_msg)

	}
	return PLUGIN_HANDLED;	
}


// send players spec
public sendSpec()
{
	new inum, players[32],player;
	get_players(players, inum)
	
	for(new i; i < inum; i++) {
		player = players[i]
		engclient_cmd(player, "spectate");
	}
}

//--------------------------------------------------------------------------------------------------
// Infection :D ------------------------------------------------------------------------------------
public random_infection()
{
	// Get a random player to be infected
	new inum, players[32];
	get_players(players, inum)
	

	new infected = players[random_num(0,inum)]

	// loop until we find a valid user to infect
	if(!is_user_connected(infected))
	{
		while(!is_user_connected(infected))
		{
			infected = players[random_num(0,inum)]
		}
	}
	// get that player name
	new InfectedPlayerName[32]
	get_user_name(infected, InfectedPlayerName, 31)

	
	infect_user(infected)
}
public infect_user(id)
{
	if(!is_user_alive(id) || !is_user_connected(id))
		return PLUGIN_HANDLED
		
	remove_task(id+TASK_ZOMBIEALERTSND);

	// Displayer others the name of the player infected
	new InfectedPlayerName[32]
	get_user_name(id, InfectedPlayerName, 31)
	// Displayer others the name of the player infected
	client_print(0, print_chat, "^^8[Zombie Infection] ^^1%s ^^8is infected! Run away from him!",InfectedPlayerName)

	// give zombie claws
	SetZombieClaws(id);

	// thunder effect
	LightningEffect(id);

	// screen effects
	fade_user_screen(id, 0.5, 3.0, ScreenFade_FadeIn, 255, 32, 32, 180);
	shake_user_screen(id, 16.0, 4.0, 16.0);

	// become zombie sound
	PlaySound(0, SND_ZMB_COMING[random(sizeof SND_ZMB_COMING)]);
	emit_sound(id, CHAN_AUTO, SND_HUMAN_DEATH[random(sizeof SND_HUMAN_DEATH)], VOL_NORM, 0.35, 0, random_num(95, 105));
	set_task(ZOMBIE_ALERT_DELAY, "ZombieAlertSnd", id + TASK_ZOMBIEALERTSND);

	set_user_info(id, "model","zombie")
	g_infected[id]=true
	
	give_item(id,"weapon_crowbar")
	
	return PLUGIN_CONTINUE
}

stock LightningEffect(id) 
{
	new footPos[3];
	GetUserFootOrigin(id, footPos);

	// thunder falls on the zombie
	new lgntningPos[3]; lgntningPos = footPos;
	lgntningPos[2] = GetLightningStart(footPos);
	te_create_beam_between_points(footPos, lgntningPos, gSprLgtning, _, _, 10, 125, 30, 255, 0, 0, 230, 100);

	// beam disc on floor
	new axis[3]; axis = footPos;
	axis[2] += 200; // beam radius
	te_create_beam_disk(footPos, gSprLgtning, axis, 0, 0, 10, _, _, 255, 0, 0, 200);

	// drop red spheres
	new eyesPos[3];
	get_user_origin(id, eyesPos, 1);
	te_create_model_trail(footPos, eyesPos, gSprLaserDot, 10, 10, 3, 25, 10); // note: 40 balls will overflow

	new origin[3];
	get_user_origin(id, origin);

	// red light for 3 seconds
	te_create_dynamic_light(origin, 20, 255, 0, 0, 30, 30);
}

stock GetUserFootOrigin(id, origin[3]) 
{
	new Float:temp, Float:ground[3];
	pev(id, pev_absmin, ground);
	temp = ground[2];
	pev(id, pev_origin, ground);
	ground[2] = temp + 2.0;

	for (new i; i < 3; i++) {
		origin[i] = floatround(ground[i]);
	}
}

stock GetLightningStart(origin[3]) 
{
	new Float:originThunder[3];
	originThunder[0] = float(origin[0]);
	originThunder[1] = float(origin[1]);
	originThunder[2] = float(origin[2]);

	while(engfunc(EngFunc_PointContents, originThunder) == CONTENTS_EMPTY)
		originThunder[2] += 5.0;

	// uncomment this if you want thunder only come out from sky
	//return engfunc(EngFunc_PointContents, originThunder) == CONTENTS_SKY ? floatround(originThunder[2]) : origin[2];
	return floatround(originThunder[2]);
}

public ZombieAlertSnd(taskid) 
{

	new id = taskid - TASK_ZOMBIEALERTSND;
	static szModelName[32];
	new bool:zmModel;
	get_user_info(id,"model",szModelName,sizeof(szModelName))
	if (equali(szModelName, "zombie"))
        zmModel = true;

	if (!is_user_alive(id) || zmModel)
		return;

	emit_sound(id, CHAN_AUTO, SND_ZMB_ALERT[random(sizeof SND_ZMB_ALERT)], VOL_NORM, 0.50, 0, random_num(95, 105));
	set_task(ZOMBIE_ALERT_DELAY, "ZombieAlertSnd", taskid);
}

public PlaySound(id, const sound[]) 
{
	new snd[128];
	RemoveExtension(sound, snd, charsmax(snd), ".wav"); // remove wav extension to avoid "missing sound file _period.wav"
	client_cmd(id, "spk ^"%s^"", snd);
}

public RemoveExtension(const input[], output[], length, const ext[]) 
{
	copy(output, length, input);

	new idx = strlen(input) - strlen(ext);
	if (idx < 0) return 0;

	return replace(output[idx], length, ext, "");
}

//--------------------------------------------------------------------------------------------------
// Disallow zombies pickup weapons and use guns ----------------------------------------------------
public fw_WpTouch(ent, id)
{
	if(!is_user_connected(id))
		return HAM_IGNORED
	
	if(g_infected[id]) 
		return HAM_SUPERCEDE
	
	return HAM_IGNORED
}
public fw_UseStaticonary(entity, caller, activator, use_type)
{
	if(is_user_connected(caller))
		return HAM_SUPERCEDE
	
	return HAM_IGNORED
}

public fw_TraceAttack(victim, inflictor, Float:damage, Float:direction[3], traceresult, damagebits)
{
	if(!victim || !inflictor) return PLUGIN_HANDLED 


	if(damagebits == DMG_CLUB && g_infected[inflictor]&&!g_infected[victim]){
		infect_user(victim)
	}

	return HAM_IGNORED
}


stock hl_strip_user_weapons(client) 
{
	new ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "player_weaponstrip")) 
	if(!pev_valid(ent))
		return 0

	dllfunc(DLLFunc_Spawn, ent);
	dllfunc(DLLFunc_Use, ent, client)
	engfunc(EngFunc_RemoveEntity, ent)

	return 1
}


public TakeDamage(victim, inflictor, attacker, Float:dmg, dmgbits)
{
	if(!victim || !attacker || !is_user_connected(victim) || !is_user_connected(attacker)) 
		return PLUGIN_HANDLED 

	// get victim and attacker models
	static sz_victimModel[32],sz_attackerModel[32]
	get_user_info(victim,"model",sz_victimModel,sizeof(sz_victimModel))
	get_user_info(attacker,"model",sz_attackerModel,sizeof(sz_attackerModel))

	// if same model => dmg = 0
	if (equali(sz_victimModel, sz_attackerModel))
	{
		dmg = 0.0
		SetHamParamFloat(4, dmg)
		return HAM_HANDLED
	}


	
	return HAM_HANDLED;
}

public CmdDrop(id) 
{
	static sz_idModel[32]
	get_user_info(id,"model",sz_idModel,sizeof(sz_idModel))
	// don't let to zombie drop his claws
	if (equali(sz_idModel, "zombie"))
	{
		client_print(id, print_console, "Can you drop part of you arm?"); 
		return PLUGIN_HANDLED;
	}
	return PLUGIN_CONTINUE;
}



// ====== EQUIP WEAPONS =========
public give_weapons(id) 
{
	if(is_user_alive(id))
	{
				give_item( id, "weapon_9mmhandgun" );
				give_item( id, "weapon_9mmAR" );
				give_item( id, "weapon_rpg");
				give_item( id, "weapon_crowbar" );	
				give_item( id, "weapon_gauss" );
				give_item( id, "weapon_egon" );
				give_item( id, "weapon_satchel" );
				give_item( id, "weapon_snark" );
				give_item( id, "weapon_handgrenade" );
				give_item( id, "weapon_hornetgun" );
				give_item( id, "weapon_tripmine" );
				give_item( id, "weapon_357" );
				give_item( id, "weapon_snark" );
				give_item( id, "weapon_crossbow" );
				give_item( id, "weapon_shotgun" );
	}
}

public FwEmitSound(id, channel, sample[], Float:volume, Float:attn, flag, pitch) 
{
	if (!is_user_connected(id))
		return FMRES_IGNORED;

	static sz_idModel[32]
	new bool:g_zmSounds[32]
	get_user_info(id,"model",sz_idModel,sizeof(sz_idModel))

	// don't let to zombie drop his claws
	if (equali(sz_idModel, "zombie"))
	{
		g_zmSounds[id] = true
	}
	if (!g_zmSounds[id])
		return FMRES_IGNORED;

	// replace default sounds with zombie sounds.
	if (equal(sample, CBAR_HIT1) || equal(sample, CBAR_HIT2)) {
		emit_sound(id, channel, SND_ZMB_HITWALL[random(sizeof SND_ZMB_HITWALL)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		return FMRES_SUPERCEDE;
	} else if (equal(sample, CBAR_HITBOD1) || equal(sample, CBAR_HITBOD2) || equal(sample, CBAR_HITBOD3)) {
		emit_sound(id, channel, SND_ZMB_HITBOD[random(sizeof SND_ZMB_HITBOD)], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
		return FMRES_SUPERCEDE;
	} else if (equal(sample, WPN_DENYSELECT) || equal(sample, WPN_SELECT) || equal(sample, GUNPICKUP2)) { // remove +use sounds
		return FMRES_SUPERCEDE;
	}

	return FMRES_IGNORED;
}

// this will clean entities like tripmines, satchels, etc...
stock ClearField() {
	static const fieldEnts[][] = { "bolt", "monster_snark", "monster_satchel", "monster_tripmine", "beam" };

	for (new i; i < sizeof fieldEnts; i++)
		remove_entity_name(fieldEnts[i]);

	new ent;
	while ((ent = find_ent_by_class(ent, "rpg_rocket")))
		set_pev(ent, pev_dmg, 0);

	ent = 0;
	while ((ent = find_ent_by_class(ent, "grenade")))
		set_pev(ent, pev_dmg, 0);
	
	ent = 0;
	while ((ent = find_ent_by_class(ent, "weaponbox"))) {
		engfunc( EngFunc_RemoveEntity, ent );
	}
}

//--------------------------------------------------------------------------------------------------
